## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2401`

#### Выполнил: `Плешаков Вадим Алексеевич`

#### Вариант: `21`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Напишите программу на Java, которая выполняет следующие действия
с двумерным массивом целых чисел:
>1. Считывает с консоли размеры массива N и M, затем элементы
   массива размером N × M.
>2. Находит и выводит количество уникальных чисел в массиве.
>3. Переставляет столбцы массива в порядке возрастания суммы их
   элементов. Если суммы равны, сравнивает количество уникальных
   чисел в столбце.
>4. Выводит элементы массива по диагоналям, начиная с верхней левой диагонали (1 элемент) и двигаясь вправо и вниз.
>5. Заменяет все числа в массиве на их факториалы и выводит полученный массив.

### 2. Входные и выходные данные

#### Данные на вход

1. Программа получает на вход параметры M и N, после этого вводит элементы матрицы размером
М*N.
2. Программа определяет количество уникальных элементов в массиве.
3. Программа считает сумму чисел и количество уникальных элементов в стобцах введённой матрицы,
а затем переставляет их так, что бы столбцы шли по возрастанию суммы элементов, если последняя
равна - по количеству уникальных элементов.
4. Программа выводит главную диагональ матрицы и параллельные ей с такой же длиной.
5. Программа заменяет каждый элемент массива на его факториал.

|                   | Тип         | min значение | max значение |
|-------------------|-------------|--------------|--------------|
| M (Число 1)       | Целое число | -2147483648  | 2147483647   |
| N (Число 2)       | Целое число | -2147483648  | 2147483647   |
| a[i][j] (Число 2) | Целое число | -2147483648  | 2147483647   |

#### Данные на выход

Программа выводит введённый пользователем массив, количество уникальных элементов в нём,
массив после перестановки столбцов, элементы диагоналей и массив с заменёнными на факториалы
элементами. Массив выводится как список элементов. Так же программа выводит строки
в случае непрохождения данных проверки на дурака и в случаях когда данные не позволяют вывести
требуемое, а так же предупреждение перед заменой на факториалы.

### 3. Выбор структуры данных

Поскольку хранить необходимо целые числа, выбран тип integer. Двумерный массив
целых чисел - int[][], одномерные служебные массивы и служебные переменные - int[] и integer
соответственно.

|            | название переменной | Тип (в Java) | 
|------------|---------------------|--------------|
| Параметр M | `m`                 | `integer`    |
| Параметр N | `n`                 | `integer`    |
| Массив а   | `a`                 | `int[][]`    |


### 4. Алгоритм и математическая модель

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два вещественных числа m и n и элементы массива в количестве m*n штук.
   **Проверка параметров m и n на положительность:**
   В случае если пользователь хочет задать массив с количеством строк/столбцов не равным
   натуральным числам, программа выводит сообщение об ошибке и отказывается от дальнейшего
   взаимодействия с юзером.
2. **Вывод введённого массива:**
   После успешного ввода программа выводит получившийся массив (скорее для удобства отслеживания её работы).
3. **Подсчёт и вывод количества уникальных элементов:**
   Используя служебный массив b[], в который параллельно записаны элементы массива a[][],
   программа находит наименьший и наибольший элемент, а затем в этом диапазоне проверяет существование
   элемента с нужным значением и в случае его нахождения инкременирует счётчик cnt. Затем
   выводит полученное значение счётчика.
4. **Подсчёт сумм в стобцах:**
   Программа суммирует элементы каждого столбца введённого массива и записывает суммы как элементы служебного массива 
   sums[] длиной равной количеству столбцов.
5. **Подсчёт количества уникальных элементов в стобцах:**
   Программа записывает элементы каждого стобца в служебный массив unics[] с длиной равной
   количеству строк, а затем аналогичным описанному выше образом программа считает уникальные элементы в каждом столбце,
   и записывает полученные количества как элементы служебного массива stolb[], длиной равной количеству стобцов.
6. **Перестановка столбцов и вывод изменённого массива**
   В случае если сумма элементов столбца i больше суммы элементов столбца j, программа поэлементно меняет столбцы 
   местами, а так же меняет местами значения их сумм в соответствующем массиве (сортировка пузырьком). В случае
   равенства сумм аналогичная замена производится при неравенстве количества уникальных элементов в столбце. Затем
   выводит массив после всех перестановок. Для проверки в коде закомментирован вывод сумм и кол-ва уникальных 
   элементов в каждом стобце.
7. **Вывод элементов диагоналей:**
   В случае если количество стобцов меньше количества строк, программа выводит сообщение об отсутствии полноценных
   диагоналей. Если размеры массива удовлетворяют, то выводит элементы главной диагонали массива а так же всех
   ей параллельных диагоналей равной длины. Условно:
   a b c d e f
   g h i j k l
   m n o p q r
   Программа выведет диагонали:
   a h o
   b i p
   c j q
   d k r
8. **Замена значений на факториалы:**
   Программа предупреждает о том, что факториал определён только для натуральных чисел, а так как массив может
   содержать неположительные целые числа, вместо их факториалов будет выводиться 0. Если просто пустить в обработку
   массив с неположительными элементами, их значения будут заменены на 1 (такой уж алгоритм), что не есть хорошо,
   так как единица является собственным факториалом. Значение 0 факториал принимать не может, поэтому его появление
   в выведенном массиве можно считать просто символом свидетельствующем об отсутствии факториала у данного элемента.
   Замена на факториал осуществлена простым циклом, умножающий значение служебной переменной neue на число от 1 до 
   a[i][j] в каждой итерации и дальнейшей заменой a[i][j] на значение neue.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        //инициаизация и ввод параметров
        out.println("Введите количество строк:");
        int n = in.nextInt();
        out.println("Введите количество столбцов:");
        int m = in.nextInt();
        if((m<=0)||(n<=0)){//проверка на дурака
            out.println("Количество подразумевает натуральное число! НИЧЕГО НЕ БУДЕТ!");
        }
        if((m>0)&&(n>0)){
            //инициализация: массивы
            int[][]a=new int[n][m];//вводимый массив
            //служебные
            int[]b=new int[m*n];//одномерный аналог вводимого массива
            int[]sums=new int[m];//для подсчёта и хранения сумм по стобцам
            int[]unics=new int[n];//для подсчёта уникальных по стобцам
            int[]stolb=new int[m];//для хранения уникальных по стобцам
            //инициализация: служебные переменные
            int l = 0;//для одномерного аналога вводимого массива
            int neue=1;//для подсчёта факториалов (это по-немецки, по-англицки джава ругалась)
            //для перестановок
            int o = 0;
            int p = 0;
            int oo = 0;
            int pp = 0;
            //для подсчета уникальных
            int cnt = 0;
            int min = 2147483647;
            int max = -2147483648;
            out.println("Введите элементы массива, коих "+(m*n)+" штук:");
            for (int i=0; i<n; i++){//ввод массива
                for (int j=0; j<m; j++){
                    a[i][j] = in.nextInt();
                    b[l] = a[i][j];//вводится одновременно и одномерная копия
                    l++;}}
            out.println("Введённый массив: ");
            for (int i=0; i<a.length; i++) {//вывод введенного массива
                for (int j=0; j<a[i].length; j++){
                    out.print(a[i][j]+" ");}
                out.println();}
            //счет уникальных
            for (int i=0; i<m*n; i++){//ищем минимум и максимум массива
                if(b[i]<min){//используя его одномерную копию
                    min=b[i];}
                if(b[i]>max){
                    max=b[i];}}
            for (int i=min; i<=max; i++){//проверяем существование значений
                for (int j=0; j<m*n; j++){// от минимума до максимума
                    if (b[j]==i){cnt++;break;}}}
            out.println("Количество уникальных элементов: "+cnt);
            //счет сумм в стобцах (для дальнейшей сортировки)
            for (int j=0; j<m; j++){
                for(int i=0; i<n; i++){
                    sums[j]=sums[j]+a[i][j];}}
            //out.println();out.print("Суммы:");for(int q=0;q<m;q++){out.print(sums[q]+" ");}
            //счет уникальных по столбцам (для дальнейшей сортировки)
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    unics[j]=a[j][i];}
                min=2147483647;
                max=-2147483648;
                cnt=0;//аналогично счёту уникальных выше, отдельно расматриваем стобцы
                for (int k=0; k<n; k++){
                    if(unics[k]<min){
                        min=unics[k];}
                    if(unics[k]>max){
                        max=unics[k];}}
                for (int k=min; k<=max; k++){
                    for (int j=0; j<n; j++){
                        if (unics[j]==k){cnt++;break;}}}
                stolb[i]=cnt;}
            //out.println();out.print("Уникальные:");for(int q=0;q<m;q++){out.print(stolb[q]+" ");}
            //перестановка столбцов согласно заданию
            for(int i=0;i<m;i++){
                for(int j=i+1;j<m;j++){
                    if(sums[i]>sums[j]){//по сумме
                        o=sums[i];
                        p=sums[j];
                        sums[i]=p;
                        sums[j]=o;
                        for(int q=0;q<n;q++){
                            oo=a[q][i];
                            pp=a[q][j];
                            a[q][i]=pp;
                            a[q][j]=oo;
                            oo=0;
                            pp=0;}
                        o=0;
                        p=0;}
                    if(sums[i]==sums[j]){//в случае одинаковой суммы по количеству уникальных
                        if(stolb[i]>stolb[j]){
                            o=stolb[i];
                            p=stolb[j];
                            stolb[i]=p;
                            stolb[j]=o;
                            for(int q=0;q<n;q++){
                                oo=a[q][i];
                                pp=a[q][j];
                                a[q][i]=pp;
                                a[q][j]=oo;
                                oo=0;
                                pp=0;}}}}}
            out.println("Отсортированный массив: ");
            for (int i=0; i<a.length; i++) {//вывод массива после перестановки
                for (int j=0; j<a[i].length; j++){
                    out.print(a[i][j]+" ");}
                out.println();}
            //вывод по диагоналям согласно заданию
            out.println("Диагонали: ");
            for(int t=0; t<m+n; t++){
                for(int i=0; i<n; i++){
                    for(int j=0;j<m;j++){
                        if((i+j)==t){
                            out.print(a[i][j]+" ");
                        }
                    }
                }
                out.println();
            }
            //замена на факториалы и вывод
            out.println("Факториал определён только для натуральных чисел, для");
            out.println("отрицательных значений будет выведен 0");//забота об ОДЗ факториала
            for (int i=0; i<a.length; i++){
                for (int j=0; j<a[i].length; j++){
                    if((a[i][j]<0)||(a[i][j]>12)){a[i][j]=0;}//вывод нулей в случае элемента не из ОДЗ
                    if(a[i][j]>=0){
                        for (int k=1; k<=a[i][j]; k++){
                            neue=neue*k;}
                        a[i][j]=neue;
                        neue=1;}}}
            //если не выводить нули, то вылезут 1, но 1 это 1!
            out.println("С элементами заменёнными на их факториалы: ");
            for (int i=0; i<a.length; i++) {
                for (int j=0; j<a[i].length; j++){
                    out.print(a[i][j]+" ");}
                out.println();}}}}
```

### 6. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест для некорректных значений размеров массива:

    - **Input**:
        ```
        Введите количество строк:
         -8
        Введите количество столбцов:
         5
        ```

    - **Output**:
        ```
        Количество подразумевает натуральное число! НИЧЕГО НЕ БУДЕТ!
        ```

2. Тест для перестановок по суммам:

    - **Input**:
        ```
        Введите количество строк:
        3
        Введите количество столбцов:
        3
        Введите элементы массива, коих 9 штук:
        1 2 3 4 5 1 2 0 -3
        ```

    - **Output**:
        ```
        Введённый массив: 
       1 2 3 
       4 5 1 
       2 0 -3 
       Отсортированный массив: 
       3 2 1 
       1 5 4
       -3 0 2
       ```
3. Тест для смешанных перестановок:

   - **Input**:
       ```
       Введите количество строк:
       3
       Введите количество столбцов:
       3
       Введите элементы массива, коих 9 штук:
       3 2 1 2 2 1 1 2 1
       ```

   - **Output**:
       ```
       Введённый массив: 
      3 2 1
      2 2 1
      1 2 1 
      Отсортированный массив: 
      1 2 3
      1 2 2
      1 2 1
      ```

4. Тест для случая когда диагоналей нет:

    - **Input**:
        ```
       Введите количество строк:
       4
       Введите количество столбцов:
       3
       Введите элементы массива, коих 12 штук:
       1 3 2 4 2 3 1 5 8 4 3 2
        ```

    - **Output**:
        ```
      Введённый массив:
      1 3 2
      4 2 3
      1 5 8
      4 3 2
      Нету полноценных диагоналей
        ```

5. Тест для диагоналей:

   - **Input**:
       ```
       Введите количество строк:
     4 
     Введите количество столбцов:
     5
     Введите элементы массива, коих 20 штук:
     1 3 2 6 4 0 5 8 2 0 4 7 5 6 2 3 4 5 6 2
       ```

   - **Output**:
       ```
       Введённый массив: 
     1 3 2 6 4 
     0 5 8 2 0
     4 7 5 6 2
     3 4 5 6 2
     Отсортированный массив:
     4 1 3 2 6
     0 0 5 8 2
     2 4 7 5 6
     2 3 4 5 6
     Диагонали: 
     4 0 7 5
     1 5 5 6
       ```

6. Тест вывода 0 вместо несуществующих факториалов:

   - **Input**:
       ```
       Введите количество строк: 
     2
     Введите количество столбцов: 
     2
     Введите элементы массива, коих 4 штук:
     -4 -4 -4 -4
       ```

   - **Output**:
       ```
       Введённый массив:
     -4 -4
     -4 -4
     С элементами заменёнными на факториалы:
     0 0 
     0 0
       ```
7. Общий тест:

   - **Input**:
       ```
       Введите количество строк:
     5
     Введите количество столбцов:
     6
     Введите элементы массива, коих 30 штук:
     10 13 14 2 4 6 0 -18 -3 -9 -4 5 6 0 2 3 11 11 2 3 4 5 10 -5 -4 -1 4 3 0 0
       ```

   - **Output**:
       ```
       Введённый массив: 
       10 13 14 2 4 6
       0 -18 -3 -9 -4 5
       6 0 2 3 11 11
       2 3 4 5 10 -5
       -4 -1 4 3 0 0
       Количество уникальных элементов: 16
       Отсортированный массив:
       13 2 10 6 4 14
       -18 -9 0 5 -4 -3
       0 3 6 11 11 2
       3 5 2 -5 10 4
       -1 3 -4 0 0 4
       Диагонали:
       13 -9 6 -5 0
       2 0 11 10 4
       Факториал определён только для натуральных чисел, для
       неположительных значений будет выведен 0
       С элементами заменёнными на их факториалы:
       1932053504 2 3628800 720 24 1278945280
       0 0 0 120 0 0
       0 6 720 39916800 39916800 2
       6 120 2 0 3628800 24
       0 6 0 0 0 24
```
